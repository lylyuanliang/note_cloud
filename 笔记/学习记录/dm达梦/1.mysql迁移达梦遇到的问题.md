# 1.自增列无法insert(比如导入)

> 解决办法: 在insert语句前面加上
>
> ```sql
> set IDENTITY_INSERT 表名 on;
>
> ```
>
> 语法说明
> `SET IDENTITY_INSERT [ [ database_name . ] schema_name . ] table_name { ON | OFF }`

# 2.代码中insert语句当id字段(自增列)有值时插入不成功(比如用mybatis-plus的insert方法)

> ![1689239978499](image/1.mysql迁移达梦遇到的问题/1689239978499.png)
>
> 解决办法: 其实就是插入时不设置主键 (如果你的需求就是要设置主键, 以下方法就没办法了)
>
>> tkmybatis: 使用下面的方法
>>
>> ```java
>> entityDao.insertSelective(entity);
>> ```
>>
>> mybatis-plus: 使用扩展  **SQL 自动注入器接口 `ISqlInjector`**, *注意:以下做法会替换掉原来的insert逻辑, 可以直接修改下*
>>
>> ![1689930240603](image/1.mysql迁移达梦遇到的问题/1689930240603.png)
>>

# 3.pagehelper无法获取数据库类型

> ![1689235786259](image/1.mysql迁移达梦遇到的问题/1689235786259.png)
>
> 解决办法:
>
> 第一种：
>
>> 切换到达梦数据库下需要设置此参数，否则分页无效
>> PageHelper.helperDialect=oracle
>>
>> ```yml
>> # 可以在application.yml中直接增加如下配置
>> pagehelper:
>>   helperDialect: oracle
>> ```
>>
>
> 第二种：
>
>> PageHelper版本高点(至少5.1.4)就行，使用方法跟其他数据库一样的。gitee上有的[https://gitee.com/free/Mybatis_PageHelper](https://gitee.com/free/Mybatis_PageHelper)
>>
>> ![1689237439266](image/1.mysql迁移达梦遇到的问题/1689237439266.png)
>>

# 4.函数部分对比

> [官方说明](https://eco.dameng.com/document/dm/zh-cn/pm/function.html)
>
> | 函数名        | 是否支持 | 其他说明                                                  |
> | ------------- | -------- | --------------------------------------------------------- |
> | CONCAT        | 支持     | 顺序联结多个字符串成为一个字符串                          |
> | from_unixtime | 支持     | from_unixtime(unixtime)<br />from_unixtime(unixtime, fmt) |
> | IF            | 支持     |                                                           |
> | json_extract  | 支持     | json_extract 获取 JSON 字符串中指定“名称”对应的“值”   |
> | date_format   | 支持     |                                                           |
> | now           | 支持     |                                                           |
> |               |          |                                                           |
> |               |          |                                                           |
> |               |          |                                                           |
> |               |          |                                                           |
> |               |          |                                                           |
> |               |          |                                                           |
> |               |          |                                                           |

# 5 case when执行结果不一致

> 解决办法:
>
> 办法一:
>
>> 因为我的逻辑是不为空时计算最大值, 原sql为
>>
>> ```sql
>> select case when id <> ' ' then max(id) else 0 end as id select xxx
>> ```
>>
>> 可能原因是在mysql中, `' '` 被隐藏转换成了0, 所以能查出结果, 但实际值只会有null和数字,  被因此换一种方式, 使用mysql和达梦都支持的函数 `ifnull `, 上述 `搜索case when `在表不为空时也可以改为 `简单case when `(`简单case when` 在表为空时返回null)
>>
>> ```sql
>> # IFNULL(n1,n2)	当 n1 为非空时，返回 n1；若 n1 为空，则返回 n2
>> # 还有另一个NULLIF, 但是nullif函数在表为空时返回null, 而ifnull在表为空时返回0
>> select ifnull(max(id), 0) as id from xxx
>> ```
>>
>> 对于 `' '`的对比结果
>>
>> ![1689318858461](image/1.mysql迁移达梦遇到的问题/1689318858461.png)
>>

# 6 日期匹配问题

> 原sql为
>
> ```sql
> select * from xxx where date=date_format(now(), '%y-%m-%d')
> ```
>
> 发现在达梦和mysql中的结果不一样, 原因是数据库存储的是 `YYYY-MM-DD`格式, `%y-%m-%d`在mysql中可以进行匹配, 但是达梦需要严格匹配, `%y`表示两位数的年,
>
> 解决办法
>
> `%y`改为 `%Y`,

# 7 关键字/保留字处理

> 情况一: mapper(自定义sql)
>
>> 写两套sql(达梦和mysql分开写)
>>
>> 例如mapper.xml
>>
>> ![1689921067406](image/1.mysql迁移达梦遇到的问题/1689921067406.png)
>>
>> 或者 实现 `org.springframework.context.annotation.Condition`, 来根据不同环境加载不同的bean, 例如
>>
>> ![1689922035512](image/1.mysql迁移达梦遇到的问题/1689922035512.png)
>>
>
> 情况二: 实体类(用框架内置方法框架内置方法进行增删查改)
>
>> tk-mybatis 解决办法:  保证mapper的依赖版本大于等于 3.5.0 (3.4.X不支持), 然后配置mapper.wrap-keyword, 样例如下
>>
>> ```xml
>> <dependency>
>>     <groupId>tk.mybatis</groupId>
>>     <artifactId>mapper</artifactId>
>>     <version>3.5.0</version>
>> </denpendcy>
>> ```
>>
>> 配置如下,
>>
>> ```yaml
>> # mysql配置wrap-keyword: '`{0}`', oracle和达梦配置wrap-keyword: '"{0}"', 请根据自己数据库的关键字转义符进行配置
>> # 对应实体类 tk.mybatis.mapper.entity.Config#wrapKeyword
>> mapper:
>>   wrap-keyword: '`{0}`'
>> ```
>>
>> mybatis-plus 解决办法: [配置说明地址](https://baomidou.com/pages/56bac0/#columnformat)
>>
>> 配置如下,
>>
>> ```yaml
>> # 对应的源码 com.baomidou.mybatisplus.core.config.GlobalConfig.DbConfig#columnFormat, 版本需要大于等于3.3.1
>> mybatis-plus:
>>   global-config:
>>     db-config:
>>      # mysql配置column-format: "`%s`", oracle和达梦配置column-format: "\"%s\"", 请根据自己数据库的关键字转义符进行配置
>>       column-format: "\"%s\""
>> ```
>>

# 8 MySQL ON UPDATE CURRENT_TIMESTAMP

> 达梦不支持这个, 可以使用触发器(更新时, update_time这类字段由数据库设置默认值)
>
> ```sql
> -- 以下脚本纯手打, 可能会有单词打错
> -- 给相应字段设置默认值 CURRENT_TIMESTAMP(3)
> alter table [schema].[表名] alter column ["更新时间"字段的名称] set default (CURRENT_TIMESTAMP(3));
>
> -- 创建相应的触发器
> create or replace trigger [schema].[触发器名称]
> before UPDATE on [schema].[表名] referencing OLD ROW AS "OLD" NEW ROW AS "NEW" for each row
> BEGIN :new.["更新时间"字段的名称]=CURRENT_TIMESTAMP(); END;
> ```
>
> 额外说明: 如果表字段比较多的话, 可以借助工具生成sql执行, 以下以excel为例
>
>> ```
>> =TRIM(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(B:B, "[custom_table]", A:A), "[trigger_name]", A:A), "[custom_column]", "UPDATE_TIME"))
>> ```
>>
>> 说明
>>
>> excel中A列表(函数汇总的A:A)为所有需要建触发器的表名, 达梦中查询所有包含某个字段的sql参考如下:
>>
>> ```sql
>> select * from user_col_comments where owner='custom_schema' and column_name='custom_column_name'
>> ```
>>
>> excel中B列表示sql模板, 如下: ([custom_table_name]的值为A列中的值, [custom_column_name]为你的更新时间字段, 例如函数中的"UPDATE_TIME")
>>
>> ```sql
>>
>> alter table custom_schema.[custom_table_name] alter column [custom_column_name] set default (CURRENT_TIMESTAMP(3));
>> create or replace trigger custom_schema.TRG_[custom_table_name]
>> before UPDATE on custom_schema.[custom_table_name] referencing OLD ROW AS "OLD" NEW ROW AS "NEW" for each row
>> BEGIN :new.[custom_column_name]=CURRENT_TIMESTAMP(); END;
>> ```
>>
>>

# 9 Select count(*)>=1 from xxx

> 这种写法在mysql中可以执行, 但是在达梦中不支持, 参考修改方案如下:
>
> ```sql
> select case when exists(
>     select id from xxx 
> ) then true else false end as exists_result
> ```
