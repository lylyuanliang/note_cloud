**简单工厂**和**工厂方法模式**都是设计模式中的创建型模式，旨在将对象的创建过程与使用过程分离，以提高代码的灵活性和可扩展性。两者有相似的目的，但在实现方式和使用场景上有所不同。

我们以下面场景为例：定义一个日志系统，有多种日志格式（如文件日志、数据库日志）。我们可以使用工厂方法模式来实现日志的创建。

### 1. 简单工厂模式

简单工厂模式（Simple Factory）通过一个**工厂类**来创建产品对象，它根据传入的参数决定实例化哪种具体产品。因此，简单工厂也称为 **静态工厂** 。

#### 特点

* **产品创建集中** ：简单工厂模式将所有产品的创建逻辑集中在一个工厂类中。
* **不符合开闭原则** ：每次添加新产品都需要修改工厂类，增加了维护成本。
* **适用于产品种类较少的场景** ：简单工厂适用于产品种类变化较少的情况，因为添加新产品需要修改工厂类。

```java
public class SimpleLogFactory {
    public static Log createLog(String type) {
        if ("file".equalsIgnoreCase(type)) {
            return new FileLog();
        } else if ("database".equalsIgnoreCase(type)) {
            return new DatabaseLog();
        } else {
            throw new IllegalArgumentException("Unknown log type");
        }
    }
}

```

### 2. 工厂方法模式

工厂方法模式（Factory Method）通过**定义抽象工厂接口**和**具体工厂类**来创建对象。每个具体工厂负责创建一种具体产品，使得对象的创建延迟到子类进行。这种方式符合 **开闭原则** ，因为每新增一种产品时，可以通过添加新的工厂类来完成。

#### 特点

* **符合开闭原则** ：增加新产品只需扩展新的具体工厂类，无需修改已有代码。
* **代码结构更复杂** ：工厂方法模式需要更多的类和接口，代码结构比简单工厂复杂。
* **适用于产品种类变化较多的场景** ：当产品种类较多且频繁变化时，工厂方法模式更适合

```java
// 抽象工厂接口
public abstract class LogFactory {
    public abstract Log createLog();
}

// 文件日志工厂
public class FileLogFactory extends LogFactory {
    @Override
    public Log createLog() {
        return new FileLog();
    }
}

// 数据库日志工厂
public class DatabaseLogFactory extends LogFactory {
    @Override
    public Log createLog() {
        return new DatabaseLog();
    }
}

```

### 3. 区别总结

| 比较维度                 | 简单工厂模式                       | 工厂方法模式                             |
| ------------------------ | ---------------------------------- | ---------------------------------------- |
| **类的结构复杂度** | 结构简单，所有产品由一个工厂类创建 | 结构复杂，每个具体产品都有对应的具体工厂 |
| **开闭原则**       | 不符合，需要修改工厂类             | 符合，通过增加工厂类支持新产品           |
| **适用场景**       | 产品种类较少且变化较少             | 产品种类较多且变化较多                   |
| **实现方式**       | 使用静态方法，根据参数实例化产品   | 抽象工厂定义接口，由具体工厂创建具体产品 |

#### 总结

* **简单工厂**适用于产品种类较少且变化不频繁的场景，结构简单，但不符合开闭原则。
* **工厂方法模式**适用于产品种类多且变化频繁的场景，结构较复杂，但符合开闭原则，便于扩展。
